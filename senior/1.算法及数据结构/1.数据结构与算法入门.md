

> 进阶 https://github.com/trekhleb/javascript-algorithms/blob/master/README.zh-CN.md

# 引入一

## 为什么要学数据结构和算法

早期前端所做工作范围有限，算法的用途并不明显，而且很多算法相关的书籍也照顾不到入门需要，所以算法和数据结构也一直被前端所忽视。长此以往，一直从事简单、重复的劳动，很容易陷入发展瓶颈

随着技术发展，前端承载了越来越多的工作，用户体验要求越来越高，对前端提出了更高的要求，前端这个职能，必须提高自身才能继续发展，未来的网页 UI，绝对不是靠几个选择器操作加超链接就能应付的。**越来越复杂的产品和基础库，需要坚实的数据结构与算法基础才能驾驭**。

而且，现在越来越多的企业在面试考核时，也加入了算法相关的考察。所以不论从哪个方面看，我们都应该学习掌握相关的知识，来适应市场需要。

## 数据结构和算法的重要性

> 算法 + 数据结构 = 程序  -- 尼克劳斯·沃思(Nicklaus Wirth)

上面等式概括了计算机编程的精要，除了“Hello world!”等无关紧要的程序，任何一个有些规模的程序都需要某种类型的数据结构来保存程序中用到的数据，还需要一个或多个算法将数据从输入转换为输出。

像我这种非科班出身，没有在学校学习过计算机科学的程序员来说，唯一熟悉的数据结构就是数组。在处理一些问题时，数组无疑是很好的选择，但对于很多复杂的问题，数组就显得太过简陋了。大多数有经验的程序员都愿意承认这样一个事实:

**对于很多编程问题，当他们想出一个合适的数据结构，设计和实现解决这些问题的算法就变得手到擒来**

学习算法非常重要，**因为解决同样的问题，往往可以使用多种算法。对于高效程序员来说，知道哪种算法效率最高非常重要**。比如，现在至少有六七种排序算法，如果知道快速排序比选择排序效率更高，那么就会让排序过程变得高效。又比如，实现一个线性查找的 算法很简单，但是如果知道有时二分查找可能比线性查找快两倍以上，那你势必会写出一 个更好的程序

深入学习数据结构和算法，**不仅可以知道哪种数据结构和算法更高效，还会知道如何找出最适合解决手头问题的数据结构和算法**（++有时候最适合的不一定是最高效的，但可以通过增加约束来提高效率 -- 个人理解，后面补充++）。写程序，尤其是用 JavaScript 写程序时，经常需要权衡，当了解了数据结构和算法的优缺点，在解决具体的编程问题时就容易做出正确的选择。

## 学习建议

学习之初，在查阅非 JS 相关的算法书籍时，常常因为一些算法、数据结构的表述和 JS 中的表现存在一定差异，给学习带来一定的困扰。所以下面给出一些建议：

1. 掌握 JS 基础，包括变量声明、变量作用域、函数、判断结构、循环结构、递归等内容（默认大家都已掌握）。**递归要清楚执行过程**，很多时候需要用到。
2. 先从 JS 相关的算法书入手，如《数据结构与算法Javascript描述》（刺猬书）、《学习Javascript数据结构与算法》（图灵书，个人感觉比刺猬书好一些）；然后再去看其他的入门书籍，如《啊哈算法》；当掌握这些入门知识后，再去攻克算法红宝书《算法导论》。循序渐进方能走的更远。注意：**书中的例子经常会有问题，要记得自己实现一遍来确认**
3. 后面需要刷题的话，建议 LeetCode。而且要一边刷一边总结，学习他人的思路。

## Javascript 语言的特殊限制（后面补充）

数组即对象、无处不在的全局变量、基于原型的对象模型

# 引入二

## 数据结构

> 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作等相关问题的学科。

### 1. 基本概念和术语

- 数据：描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。
- 数据对象：是性质相同的数据元素的集合，是数据的子集。（一般会将数据对象简称数据）
- 数据元素：组成数据的、有一定意义的基本难为，在计算机中通常作为整体处理。
- 数据项：一个数据元素可以有若干个数据项组成，且数据项是数据不可分割的最小单位。

数据结构：相互之间存在一种或多种特定关系的数据元素的集合。

### 2. 数据结构分类

- 逻辑结构：数据对象中数据元素之间的相互关系
    - 集合结构
    - 线性结构
    - 树形结构
    - 图形结构
- 物理结构/存储结构：数据的逻辑结构在计算机中的存储形式
    - 顺序存储结构
    - 链式存储结构

## 算法

> 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

### 1. 特性

- 输入输出：绝大多数都需要输入，每个都需要输出
- 有穷性：算法在执行有限步骤后，自动结束不会无限循环，且步骤执行时间可接受
- 确定性：每步骤都具有确定含义，不出现二义性（一定条件下，执行路径唯一，同一输入只能同一输出）
- 可行性：每步都可行，每步都能通过执行有限次数完成

### 2. 设计要求

- 正确性：算法至少具有输入、输出、加工处理无歧义，正确反映问题需求，得到问题正确答案
- 可读性：算法设计的另一目的是为了便于阅读、理解、交流
- 健壮性：当输入数据不合法时，也能作出处理，而不是异常或怪异结果
- 时间效率高、存储量低：更少的资源、更快的解决

### 3. 算法时间复杂度和大O阶

- 算法时间复杂度
    - 在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间度量，记做 **T(n) = O(f(n))**。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率下相同，称为**算法的渐进时间复杂度**，简称时间复杂度。其中 f(n) 是问题规模 n 的某个函数。

- 推导大O阶
    1. 用常数1取代运行时间中的所有加法常数
    2. 在修改后的运行次数函数中，只保留最高阶项
    3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数

- 常见时间复杂度

    效率：O(1) < O(㏒n) < O(n) < O(n㏒n)< O(n²)< O(n³)< O(2^n)< O(n!)< O(n^n)

    执行次数函数 | 阶 | 非正式术语
    ---|---|---
    2 | O(1) | 常数阶
    2n+3 | O(n) | 线性阶
    3n²+2n+1 | O(n²) | 平方阶
    3㏒n+2 | O(㏒n) | 对数阶
    2n+3n㏒n+5 | O(n㏒n) | n㏒n阶
    4n³+3n²+2n+1 | O(n³) | 立方阶
    2^n | O(2^n) | 指数阶


# 一、数组 Array

> 数组是计算机编程世界里最常见的数据结构，是编程语言中的内建类型，通常效率很高，可以满足不同需求的数据存储。

数组可以说是学习使用 Javascript 时，接触最早、使用最多的数据结构，因为一些原生的功能支持，在使用上也颇为顺手。当然，Javascript 中的数组和其他编程语言又有一些不同，下面我们就以数组为切入点，来开始学习数据结构和算法。

## 1.1 标准定义

一个存储元素的线性集合(collection)，元素可以通过索引来任意存取，索引通常是数字，用来计算元素之间存储位置的偏移量。

## 1.2 特点

1. Javascript 中的数组使用对象实现的，性能略低；但可以使用对象的属性和方法。

    JavaScript 中的数组是一种特殊的对象，用来表示偏移量的索引是该对象的属性，索引可能是整数。**然而，这些数字索引在内部被转换为字符串类型，这是因为 JavaScript 对象中 的属性名必须是字符串**。数组在 JavaScript 中只是一种特殊的对象，所以效率上不如其他语言中的数组高。

    JavaScript 中的数组，严格来说应该称作对象，是特殊的 JavaScript 对象，在内部被归类为数组。由于 Array 在 JavaScript 中被当作对象，因此它有许多属性和方法可以在编程时使用。
    （具体用途待补充）

2. 可以在数组中保存不同类型的值

    标准数组存储一系列同一种数据类型的值，但我们还是要遵守最佳实践，别这么做(大多数语言都没这个能力)。

3. 数组长度可以动态改变

    很多语言中，创建数组时需要声明长度，且不可修改，如果长度需要改变要创建新数组，所以在查阅其他语言的算法书籍时，这是一个非常大的差别，影响很多与之相关的实现方式。

4. 修改数组的性能较高

    由于内部实现了一些方法，push、pop、unshift、shift，使得 Javascript 中的数组在修改上的性能要高了很多，尤其是非数组结果的修改。（个人总结，待商榷）

## 1.3 使用数组

后面需要学习的算法，很多都依赖于数组来实现，所以我们先来看下数组相关的方法。

### 1.3.1 创建

- [] 字面量
    - 公认效率最高（待扩展：为什么效率最高？）
    - 创建时可以直接指定内容，[1,2,3]
- new Array() 构造函数
    - 无参数创建空数组
    - 1个 Number 参数创建指定长度数据，其他类型参数作为内容创建数组
    - 多个参数则作为内容创建数组
- String.prototype.split 字符串生成数组
    - 数组转回字符串 Array.prototype.join
- Array.prototype.concat
    - 接受多个数组参数
    - 返回一个全新数组，不影响原数组
- Array.prototype.slice
    - 返回新数组，内容为原数组[a, b)元素
- 迭代器
    - Array.prototype.map
    - Array.prototype.filter

### 1.3.2 读取

- arr.xxx
- arr[xxx]

### 1.3.3 修改

- 添加元素
    - 结尾添加
        - Array.prototype.push
            - 原生能力，效率高
            - 可以一次添加多个
            - 时间复杂度 O(1)，和其他语言相同
        - arr[arr.length] = xxx
            - 一次只能一个
            - 时间复杂度 O(1)
    - 开始添加
        - Array.prototype.unshift
            - 原生能力，效率高
                - 问题：数组长度足够大的时候，性能也不行吧？待确认
            - 时间复杂度 O(1) ，和其他语言不同，其他语言要主动处理下标
                - 问题：是 O(1) 吗？
        - arr[0] = xxx
            - 此时需要手动将数组其他元素下标+1
            - 时间复杂度 O(n)，和其他语言相同
    - 中间添加
        - Array.prototype.splice
            - arr.splice(5,0,x,y,z) 从索引5开始，删除0个，插入xyz
- 删除元素
    - 结尾删除
        - Array.prototype.pop
            - 原生能力，效率高
            - 可以一次添加多个
            - 时间复杂度 O(1)
        - arr.length = arr.length - 1
            - 可以通过设置长度来减少尾部元素，不限1个，设为0时清空数组
            - 时间复杂度 O(1)
    - 开始删除
        - Array.prototype.shift
            - 原生能力，效率高，且不用考虑数组长度、其他元素下标问题
            - 时间复杂度 O(1)
        - 循环处理
            - 此时需要手动将数组其他元素下标+1
            - 时间复杂度 O(n)
    - 中间删除
        - Array.prototype.splice
            - arr.splice(5,3) 表示删除从索引5开始的3个元素
- 修改元素
    - arr[index] = xxx
        - 时间复杂度 O(1)
        - 数组的读取快速的根因所在
    - arr.splice(5,3,x,y,z) 修改的时候，要插入和删除元素数量相同的内容，此处删3个，插入3个

> - 通过push和pop方法，可以用数组来模拟栈
> - 通过shift和unshift方法，可以用数组模拟基本的队列数据结构

### 1.3.4 搜索和排序

我们学习算法的目的，也就是想掌握如何编写最常用的搜索和排序算法，Javascript 中的数组提供了基础的方法。

- indexOf、lastIndexOf 查索引
- sort 排序，默认按字典排，所以一般自定义排序方法函数
- reverse 反转顺序

### 1.3.5 其他迭代器

- some、every 返回 Boolean 值
- forEach 无返回
- reduce、reduceRight
    - reduce 是一个很神奇的东西【累加器】，redux 的 combineReducers 方法中就有应用到 reduce 用于组合 state

**上面的方法**

## 1.4 二维、多维数组

原生并不支持二维、多维数组，可以模拟实现，因为数组的元素也可以是数组。这个在后面学习会用得到（）

### 1.4.1 创建

1. 字面量创建。适用于少量数据
```javascript
var arr = [[1,2,3], [4,5,6]]
```
2. 循环创建。最容易想到的创建方式，但是空数组的内容是undefined，建议用下面的方法
```javascript
Array.matrix = function(numrows, numcols, initial) {
    var arr = [];
    for (var i = 0; i < numrows; ++i) {
        var columns = [];
        for (var j = 0; j < numcols; ++j) {
          columns[j] = initial;
        }
        arr[i] = columns;
    }
    return arr;
}
```

### 1.4.2 遍历操作

在遍历的过程中，如果多维数组不像前面创建的一样，是固定行、列数的话，就需要注意循环的条件，通常我们采用以下方式：

```javascript
for (var row = 0; row < arr.length; ++row) {
    for (var col = 0; col < arr[row].length; ++col) {
       // ... dosomething
    }
 }

```
从上面代码看，二维数组需要两层 for 循环来实现遍历，同理 N 维数组自然就需要 N 层循环来处理。至于执行的复杂度问题，暂时不考虑，普通应用场景比较少用多维的，后面遇到时再看下具体的优化方式。


## 1.5 小结

在本章中，我们学习了**最常用的数据结构:数组**。我们学习了如何声明和初始化数组、给数组赋值、操作数组、排序查询等主要方法，还学习了二维和多维数组。这对我们在后面章节中编写自己的算法很有用。

## 1.6 扩展

为什么其他语言中数组的尾插、尾删的时间复杂度是O(1)，其他位置操作的时间复杂度是O(n)？换言之，数组适合频繁查询、随机查询，不适合频繁操作。

```javascript

```

# 二、栈 Stack

前面学习的数组可以任意地方添加、删除元素。有时我们需要**管控元素操作的位置，使其更为可控**，它们就是栈和队列。我们现学栈。

## 2.1 基础概念

> 栈是一种遵从后进先出(LIFO)原则的**有序**集合，限定仅在表尾进行插入和删除操作的线性表。

1. 新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。
2. 栈是一种高效的数据结构，因为数据只能在栈顶添加或删除，所以这样的操作很快，而且容易实现。
3. 栈的使用遍布程序语言实现的方方面面，内存中保存变量、表达式求值、处理函数（方法）调用等。

生活中常见的栈的例子：厨房的盘子、手枪的弹夹。

堆栈最早由 Alan M. Turing(艾伦·图灵，图灵奖以他命名)于 1946 年提出，当时是为了解决子程序的调用和返回。

## 2.2 创建栈

首先，我们需要一种数据结构来保存栈里的元素，这里我们选择数组。

然后，考虑下所需的基本功能（方法），思考切入点增、删、改、查。

- 增：push 添加元素到栈顶
- 删：pop 移除栈顶元素，并返回；clear 清空栈
- 改：无
- 查：peek 查询栈顶元素但不移除；isEmpty 查看栈是否为空；size 查看栈中元素个数
    - 由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问  

代码实现1：
```javascript
function Stack() {
    var items = [];
    this.push = function(element){
        items.push(element);
    };
    this.pop = function(){
        return items.pop();
    };
    this.peek = function(){
        return items[items.length-1];
    };
    this.isEmpty = function(){
        return items.length ** 0;
    };
    this.size = function(){
        return items.length;
    };
    this.clear = function(){
        items = [];
    };
    this.print = function(){
        console.log(items.toString());
    };
}
```
代码实现2：增加了一个指针top，没有提供 length 方法，数组并没清空，指针的引入更像其他语言的实现
```javascript
function Stack() {
    this.dataStore = [];
    this.top = 0;
    this.push = push;
    this.pop = pop;
    this.peek = peek;
    this.clear = clear;
    this.length = length;
}
function push(element) {
    this.dataStore[this.top++] = element;
}
function peek() {
    return this.dataStore[this.top-1];
}
function pop() {
    return this.dataStore[--this.top];
}
function clear() {
    this.top = 0; // 只设置top，数组并未清空，有没有一种场景需要不清除？暂时没想到。清除的话可以设置 this.dataStore.length = 0;
}
function length() {
    return this.top;
}
```

## 2.3 使用栈

下面我们来看几个题目，通过使用加深对栈的了解

### 2.3.1 数制转换（十进制转其他）

先说明一下数值转换，十进制数字和目标进制整除(二进制是满二进一)，直到结果是0为止，在 Javascript 中就是取余计算。

```javascript
function baseConverter(num, base) {
    var s = new Stack();
    var rem;
    // 取余分位入栈
    do {
        rem = Math.floor(num % base);
        s.push(rem);
        num = Math.floor(num / base);
    } while (num > 0);

    var converted = "";
    var digits = '0123456789ABCDEF';

    // 出栈拼接
    while (!s.isEmpty()) { // 或判断 s.length() > 0
       converted += digits[s.pop()];
    }

    return converted;
}
```

### 2.3.2 回文判断

回文是一种现象:一个单词、短语或数字，从前往后写和从后往前写都是一样的。如，单词“dad”、“racecar”就是回文。

```javascript
function isPalindrome(word) {
    var s = new Stack();

    // 入栈
    for (var i = 0; i < word.length; ++i) {
       s.push(word[i]);
    }

    // 出栈
    var rword = "";
    while (s.length() > 0) {
       rword += s.pop();
    }

    return word == rword;
}
```

上面的实现还有没有其他实现方式？

- 使用字符串和数组的方法实现
    - String.prototype.split、Array.prototype.reverse、Array.prototype.join 方法
    - ''.split('').reverse().join('')
- 前半部分和后半部分对比
    - 通过观察可知，回本必须是中间对称的，所以我们计算获的中间值，将其左侧入栈，然后顺序出栈和中间值右侧内容对比
    - 这种方式和上面的实现区别在哪？慢慢体会总结
```javascript
function isPalindrome(word) {
    var s = new Stack();
    var len = word.length;
    var mid = Math.floor(len / 2 - 1);  // 注意这里要取整，不然那下面出栈计算可能为小数，导致计算出错

    // 入栈
    for (var i = 0; i <= mid; ++i) {
       s.push(word[i]);
    }

    // 获取对比的起点
    var next;
    if(len % 2 ** 0) {
        next = mid + 1; // 下一个
    } else {
        next = mid + 2; // 跳过一个中间值
    }

    // 出栈
    for (var i = next; i < len; ++i) {
       if(s.pop() != word[i]) {
           return false;
       }
    }

    return true;
}
```

### 2.3.3 算式括号匹配（平衡圆括号）

算术表达式要求括号要对称，写一个方法判断括号是否匹配，并返回不匹配的位置

```javascript
```

### 2.3.4 中缀表达式改后缀表达式

中缀表达式：a + b ; 后缀表达式 a b +

```javascript
```

### 2.3.5 汉诺塔

## 2.4 总结

栈是个比较简单的数据结构，具体的应用和注意事项后续刷题的时候添加。

# 三、队列 Queue

当提起的栈的时候，总是会很自然的想起队列。这两种数据结构非常相似，但是使用了不同的员额，可以比对着学习。

## 3.1 基础概念

> 队列是一种弄遵循先进先出(FIFO First In First Out)原则的**有序**集合，只允许一端进行插入操作、另一端进行删除操作的线性表。

生活中常见的栈的例子：排队买票、打印机任务列表。

## 3.2 创建队列

首先，我们需要一种数据结构来保存队列中的元素，同样这里我们选择数组。

然后，考虑下所需的基本功能（方法），思考切入点增、删、改、查。

> 感谢 Javascript 原生实现 push、shift

- 增：enqueue 添加元素到队尾
- 删：dequeue 移除队首元素，并返回；clear 清空队列
- 改：无
- 查：front 查询队首元素但不移除；isEmpty 查看栈是否为空；size 查看栈中元素个数；print 打印展示所有元素

代码实现：

```javascript
function Queue() {
    var items = [];
    this.enqueue = function(element){
        items.push(element);
    };
    this.dequeue = function(){
        return items.shift();
    };
    this.front = function(){
        return items[0];
    };
    this.clear = function(){
        items = [];
    };
    this.isEmpty = function(){
        return items.length ** 0;
    };
    this.size = function(){
        return items.length;
    };
    this.print = function(){
        console.log(items.toString()); // 也可以拼接成字符串输出或返回
    };
}
```

## 3.3 使用队列

队列的示例好像没什么特殊的，后面想到经典的再补充

### 3.3.1 有趣的基数排序

ps: 看上去效率一般 O(n)，又有点像桶排序，待确认

对于 0~99 的数字，基数排序将数据集扫描两次。第一次按个位上的数字进行排序，第二次按十位上的数字进行排序。每个数字根据对应位上的数值被分在不同的盒子里。以 [91, 46, 85, 15, 92, 35, 31, 22] 为例展示：

```javascript
function distribute(nums, queues, n, digit) {
    for (var i = 0; i < n; ++i) {
       if (digit ** 1) {
            queues[nums[i]%10].enqueue(nums[i]);
        } else {
            queues[Math.floor(nums[i] / 10)].enqueue(nums[i]);
        }
    }
}
function collect(queues, nums) {
    var i = 0;
    for (var digit = 0; digit < 10; ++digit) {
        while (!queues[digit].empty()) {
            nums[i++] = queues[digit].dequeue();
        }
    }
}
function dispArray(arr) {
    for (var i = 0; i < arr.length; ++i) {
        console.log(arr[i] + " ");
    }
}

// 主程序
var queues = [];
for (var i = 0; i < 10; ++i) {  // 生成十个队列用于排序
    queues[i] = new Queue();
}

var nums = [];
for (var i = 0; i < 10; ++i) {  // 生成是个0-99的随机数，特定情况下会出现101
    nums[i] = Math.floor(Math.floor(Math.random() * 101));
}

dispArray(nums);                // 生成数据
distribute(nums, queues, 10, 1);// 个位数排序
collect(queues, nums);          // 从队列中取出
distribute(nums, queues, 10, 10);// 十位数排序
collect(queues, nums);          // 从队列中取出
dispArray(nums);                // 展示结果
```

## 3.4 优先队列

特征：
1. 不遵守 FIFO 特性，优先输出优先级（Priority）高的元素
2. 当各元素以输入先后次序为优先权时，是一般队列，假如是以输入先后次序作为最不优先权时，即为栈。

实现：
1. 设置优先级，然后在正确的位置添加元素（先查后插）
2. 用入列操作添加元素，然后按照优先级移除元素（先插后查）

案例：医院急诊排队
1. 先查后插(入队查优先级，出队不变)
```javascript
function QueueElement (element, priority){      // 拥有内容和优先级字段
    this.element = element;
    this.priority = priority;
}
this.enqueue = function(element, priority){
    var queueElement = new QueueElement(element, priority);
    if (this.isEmpty()){
        items.push(queueElement);               // 第一次直接插入
    } else {
        var added = false;
        for (var i=0; i<items.length; i++){
            // 找到比待插入元素优先级高的元素 TODO 感觉有问题，会出现 10 3 5 的情况
            if (queueElement.priority < items[i].priority){
                items.splice(i,0,queueElement); // 找到则直接插入到其后面
                added = true;
                break;                          // 插入后中断循环
            }
        }
        if (!added){                            // 未找到则直接插入
            items.push(queueElement);
        }
    }
};
```
2. 先插后查(入队不变，出队查优先级)
```javascript
function dequeue() {
    var priority = this.dataStore[0].code;
    for (var i = 1; i < this.dataStore.length; ++i) {
        // 找到优先级最高的第一个
        if (this.dataStore[i].code < priority) {
            priority = i;
        }
    }
    return this.dataStore.splice(priority,1);   // 取出优先级最高的第一个
}
```

## 3.5 双向队列

- 增：rin 添加元素到队尾（右入）；lin 添加元素到队首（左入）
- 删：lout 移除队首元素（左出）并返回；rout 移除队尾元素（右出）并返回；clear 清空队列
- 改：无
- 查：front 查询队首元素但不移除；back 查询队尾元素但不移除；isEmpty 查看栈是否为空；size 查看栈中元素个数

应用：可以参考 2.3.2 中回文判断的第三种思路，使用双向队列也可以做到。（顺序右入，每次左出和右出各一比较）

## 3.6 循环队列

案例：击鼓传花（或者围成一圈数数杀人）

```javascript
function hotPotato (total, num){
    var queue = new Queue();
    for (var i=0; i< total; i++){
        queue.enqueue('人' + (i+1) );        // 按照总数生成队列
    }

    var eliminated = '';
    while (queue.size() > 1){
        for (var i=0; i<num; i++){
            queue.enqueue(queue.dequeue()); // 不淘汰的人出队后要重新入队
        }
        eliminated = queue.dequeue();       // 数到第num个被淘汰
        console.log(eliminated + '出局');
    }
    return queue.dequeue();                 // 最后剩下的就胜利者
}

var winner = hotPotato(43, 3);
console.log('胜利者:' + winner);
```

## 3.7 小结

队列在计算机领域的应用：

1. 在图形遍历的先广后深搜索法(BFS)
2. 用于计算机的模拟(simulation)
3. CPU的工作调度等

# 四、链表 LinkedList

前面学习了数组这种非常**简单、方便**的存储数据序列的数据结构。当我们需要存储多个元素时，总是最先想到数组，而且每种语言都实现了数组，一切看上去都是那么美好。但在实际运用中，有些情况下数组会不那么好用，接下来我们看下数组存在的缺点。

## 4.1 数组的缺点

在大多数语言中，数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动其他元素。尽管 JavaScript 中的 Array.prototype.splice 方法在插入、删除元素的时候可以不用主动移动其他元素，但是由于 Javascript 中的数组被实现成了对象，与其他语言（如 c++、java）相比，效率是很低的。

如果你发现数组在实际使用时很慢，就可以考虑使用链表来替代它。除了对数据的随机访问，链表几乎可以用在任何可以使用一维数组的情况中。如果需要随机访问，数组仍然是更好的选择。

## 4.2 基本概念

- 链表是由一组节点组成的集合。
- 每个节点包含元素本身内容和一个指向下一节点的引用（指针/链）。
- 链表最后一个节点的 next 始终指向 null，至于头节点不是必须的，但是一般会设置一个特殊的头节点

### 链表和数组的对比

- 引用：数组靠位置进行引用、链表靠相互关系引用
- 访问：数组可以随机访问、链表需要**从表头开始**迭代列表
- 操作：数组操作会影响其他元素、链表操作不会影响其他元素
- 存储：数组在内存中是连续放置的、链表是内存中不是连续放置的
    - 问题：js中的数组被实现为对象的话，存储是是否仍然连续？

常见链表案例：寻宝游戏、侦探游戏、火车

## 4.3 创建链表

首先，链表这种数据结构的数据元素不再是简单的数据，有两个数据项：数据和指针，所以需要增加一个辅助类 Node 节点。节点由存放数据元素的数据域和存放后继节点地址的指针域组成。

```javascript
function Node(element) {
    this.element = element;
    this.next = null;
}
```

然后，考虑下所需的基本功能（方法），思考切入点增、删、改、查。

注意：元素和节点的区别，元素是具体内容，节点包括元素内容和指针。

代码实现一：遍历节点自身的内容来操作（对象思想，基于对象），下例实现上的边界考虑不足、操作方式有限制，实现的不够好。

- 增：insert 添加元素到指定位置
- 删：remove 移除指定元素
- 改：无
- 查：display 查看所有元素；find 查询指定元素所在节点；findPrevious 查询指定元素的上一个节点
```javascript
function LinkedList() {
    this.head = new Node("head");       // 显示声明了特殊头节点
    this.find = find;
    this.insert = insert; 
    this.remove = remove; 
    this.findPrevious = findPrevious; 
    this.remove = remove;
    this.display = display;
}

// 根据内容查找节点                        // 注意：这里的实现要 查找链表已有节点 的内容，不然会报错，null 没有 element 属性
function find(item) {
    var currNode = this.head;           // 从 头节点 开始遍历
    while (currNode.element != item) {
        currNode = currNode.next;       // 不是目标节点就继续往下查
    }
    return currNode;
}

// 插入元素到指定元素「之后」，依赖于上面的 find 查找节点 
function insert(newElement, item) {     // 第一次执行要插入到 head 节点后，不然报错
    var newNode = new Node(newElement); 
    var current = this.find(item);      // 这里需要能找到具体节点，才能继续后面的操作，不然要报错
    newNode.next = current.next;        // 注意赋值顺序，先链后再链前
    current.next = newNode;             // 插入到 item 之后
}

// 查找指定节点的上一个节点
function findPrevious(item) {
    var currNode = this.head;           // 从 头节点 开始遍历，直到找到指定节点的前驱节点或到了最后一个节点
    while (currNode.next != null && currNode.next.element != item) {
        currNode = currNode.next;
    }
    return currNode;
}

// 删除节点，依赖于 findPrevious 来找到待删除节点的前一个节点
function remove(item) {
    var prevNode = this.findPrevious(item);
    if (prevNode.next != null) {        // 前驱节点的 next 指向当前节点的 next ，就把当前节点剔除出链表了
        prevNode.next = prevNode.next.next;
    }
}

// 打印链表内容
function display() {
    var currNode = this.head;           // 依然是从 头节点 开始迭代
    while (!(currNode.next == null)) {
        console.log(currNode.next.element);
        currNode = currNode.next;
    }
}
```

代码实现二：抽象一个 position 位置（不是节点属性，也不是固定索引）和 length 长度，遍历位置并以链表长度为边界来操作（数组思路，基于对象）

个人感觉这个实现的挺好，处理了边界情况、操作也有输出来明确其结果

- 增：insert 添加元素到指定位置，甚至是头节点；append 向链表尾部添加元素
- 删：removeAt 移除指定位置元素；remove 移除指定元素
- 改：无
- 查：indexOf 查找指定元素所在节点的索引；size 查看链表长度；isEmpty 查看链表是否为空；display 查看所有元素；
```javascript
function LinkedList() {
    var length = 0;                     // 手动维护一个内部变量，链表长度
    var head = null;                    // 不声明特殊头节点，但是需要存储头节点的引用，方便后面遍历
    
    // 尾部插入
    this.append = function(element){
        var node = new Node(element);
        if (head === null){             // 空链表则直接赋值给头节点
            head = node;
        } else {
            var current = head;         // 非空链表从 head 开始遍历
            while(current.next){
                current = current.next;
            }
            current.next = node;        // 遍历到最后一项，将新节点加到后面
        }
        length++;                       // 手动更新内部变量 length 
    };

    // 移除指定位置的元素
    this.removeAt = function(position){
        if (position > -1 && position < length){// 边界检查，防止出错，位置从0开始算
            var current = head,
                previous,
                index = 0;
            if (position === 0){                // 移除第一项，则需要更新头节点
                head = current.next;
            } else {
                while (index++ < position){     // 移除其他项，则遍历 position 找到当前节点和前驱节点
                    previous = current;
                    current = current.next;
                }
                previous.next = current.next;   // 将前驱节点的 next 指向当前节点的 next（后继节点），当前节点就删除了
            }
            length--;                           // 手动更新
            return current.element;             // 放回被删除元素
        } else {
            return null;                        // 边界外的不删除
        }   
    };

    // 插入元素到指定位置「之前」（和尾部插入对比来看）
    this.insert = function(position, element){
        if (position >= 0 && position <= length){// 检查边界
            var node = new Node(element),
                current = head,
                previous,
                index = 0;
            if (position === 0){                // 特殊情况，头插
                node.next = current;            // 注意顺序
                head = node;
            } else {
                while (index++ < position){     // 依然是遍历查找到指定位置节点及其前驱节点
                    previous = current;
                    current = current.next;
                }
                node.next = current;            // 注意顺序，先新后旧
                previous.next = node;
            }
            length++;                           // 手动维护
            return true;                        // 插入成功返回 true 
        } else {    
            return false;                       // 插入失败返回 false
        } 
    };

    // 查位置
    this.indexOf = function(element){
        var current = head,
            index = 0;                          // TODO 这里应该从0开始才对
        while (current) {
            if (element === current.element) {
                return index;                   // 找到则直接返回
            }
            index++;                            // 未找到则查找下一个位置
            current = current.next;
        }
        return -1;                              // 沿用标准处理，未找到返回 -1
    };

    // 删除指定元素，借用前面的2个方法实现
    this.remove = function(element){
        var index = this.indexOf(element);
        return this.removeAt(index);
    };

    // 为空判断
    this.isEmpty = function() {
        return length === 0;
    };

    // 获取长度
    this.size = function() {
        return length;
    };

    // 返回头节点
    // 注意 头节点 是私有变量，不能在 LinkedList 实例外部被访问和更改，这里虽然给访问了，但是应该考虑禁止修改的实现。
    this.getHead = function(){
        return head;
    };
    
    // 拼接成字符串返回
    this.toString = function(){
         var current = head,
            string = ''; 
         while (current) {
            string += current.element;
            current = current.next;
        }
        return string;
    };
}
```

可优化点：insert 和 remove 失败时可以考虑把元素插入到尾部。

### 数组和单链表性能对比

- 时间性能：
    - 数组的查找是O(1)，链表的查找是O(n)；
    - 数组的增删是O(n)/O(1)，链表的增删是O(1)。
        - Javascript 中的数组增删虽然看上去是O(1)，但因为数组实现为对象，所以并不是严格意义上的O(1)
- 空间性能：
    - 其他语言数组固定长度，分大了浪费，分小了上溢，Javascript 中动态数组暂无这个问题
    - 单链表不需要分配存储空间，元素个数不受限

对于插入或删除数据越频繁的操作，单链表的效率优势越明显。

## 4.3 双向链表

单向链表的缺点是**只能从前向后查找**，当我们需要查找某个节点的后继节点是，时间复杂度固定O(1)，但当我们需要查某个节点的前驱节点时，最坏时间复杂度成了O(n)。双向链表就是为了克服这个缺点而设计的。

双向链表是在单链表的每个节点中，再设置一个指向起前驱节点的指针域。虽然插入时需要多设置一个数据项，但是删除时不用再查找前驱节点了，可以直接用，删除效率提高。

此处，我们在单链表的第二种实现基础上，看下双向链表的实现有哪些区别。
```javascript
function Node(element) {
    this.element = element;
    this.next = null;
    this.prev = null;   // 新增前驱指针
}

function DoublyLinkedList() {
    var length = 0;
    var head = null;
    var tail = null;    // 新增尾节点

    // 插入元素到指定位置
    this.insert = function(position, element){
        if (position >= 0 && position <= length){// 检查边界
            var node = new Node(element),
                current = head,
                previous,
                index = 0;
            if (position === 0){                // 头插
                if (!head){                     // 第一次头插，则头节点、尾节点都是新增节点
                    head = node;
                    tail = node;
                } else {                        // 非第一次头插
                    node.next = current;        // 先操作 next 保持链接，作为头节点只有 next 没有 prev
                    current.prev = node;        // 再操作 prev，前驱指针指向新节点
                    head = node;                // 更新头节点
                }
            } else if (position === length) {   // 尾插
                current = tail;                 // 把操作节点缓存改为 tail
                current.next = node;            // 先操作 next 保持链接
                node.prev = current;            // 再操作 prev，作为尾节点，没有 prev ，只设置 next
                tail = node;                    // 更新尾节点
             } else {                          
                while (index++ < position){     // 中间插入，则需要遍历了
                    previous = current;
                    current = current.next;
                }                               // 重点记住下面的顺序，next新 - next旧 - prev旧 - prev新 
                node.next = current;            // 问题：能不能调换熟顺序？
                previous.next = node;
                current.prev = node;
                node.prev = previous;
            }
            length++;                           // 手动维护
            return true;                        // 插入成功返回 true 
        } else {    
            return false;                       // 插入失败返回 false
        } 
    };

    // 移除指定位置的元素
    this.removeAt = function(position){
        if (position > -1 && position < length){// 边界检查，防止出错，位置从0开始算
            //移除第一项
            if (position === 0){                // 头删
                head = current.next;            // 改变 head 引用下一元素
                if (length === 1){              
                    tail = null;                // 特殊情况，只有一个元素还被移除了，则 tail 也是 null
                } else {
                    head.prev = null;           // 注意新头节点的前驱指针应该指向 null
                }
            } else if (position === length-1){  // 尾删
                current = tail;                 // 修改中间变量的引用
                tail = current.prev;            // 这里不再需要考虑长度为一的情况，直接操作
                tail.next = null;               // 注意新尾节点的后继指针应该指向 null
            } else {                            
                while (index++ < position){     // 中间删，遍历查找
                    previous = current;
                    current = current.next;
                }
                previous.next = current.next;   // 先 next 
                current.next.prev = previous;   // 后 prev
            }
            length--;                           // 手动更新
            return current.element;             // 放回被删除元素
        } else {
            return null;                        // 边界外的不删除
        }   
    };

    // 。。。其他方法
}
```

可优化点：insert 和 remove 可以先判断 position 是在 length/2 的左还是右，来决定从哪端开始遍历。

## 4.4 循环链表

将单链表中终端节点的指针端由空指针改为指向头节点，就使得整个单链表形成一个环，单循环链表简称循环链表。

对比单链表：

- head.next = head，最后一个节点 next 不再指向 null
- 同时，遍历的终止条件由  next = null 修改为 next = head
- 循环链表解决问题：从一个任一个节点都可以访问完所有节点
- 技巧：使用尾节点来作为基础点，头节点 = 尾节点.next，访问效率提升

还有一种双循环列表，看名次大概就知道是什么意思了，有兴趣自己实现下，方法大体上是相同的。

## 4.5 总结

对比着数组来学习理解链表，总是能事半功倍。数组适合频繁的随机访问，链表适合频繁的随机操作。

除了上述的基本方法，好用的链表还需要增加 advance 前移N位、back 后移N位、show 显示当前节点等方法。可以根据需要添加，并体会起实现的意义。

# 五、集合 Set

前面学习的几种数据结构都是顺序数据结构 / 线性数据结构，接下来我们会学习三种无序的数据结构 / 非线性数据结构。先学习集合。

## 5.1 基础概念

- 集合：由一组无序且唯一的元素（成员）组成
- 空集：不包含任何元素的集合
- 全集：包含一切可能成员的集合
- 子集：一个集合所有成员都属于另外一个集合，则是其子集

两个特性：成员无序、成员唯一

很多编程语言中并不把集合当成数据类型，不过 ECMAScript2015 标准中已经实现了 Set 类。接下来的学习是以 ES6 中 Set 类的实现为基础展开的。

## 5.2 创建集合

首先，我们需要一种数据结构来保存集合中的元素，考虑 Javascript 中的对象不允许一个键指向两个不同属性，用它来确保集合元素唯一很不错，所以我们选择使用对象而非数组来表示集合（当然数组也可以实现）。

然后，考虑下所需的基本功能（方法），思考切入点增、删、改、查。

- 增：add 给集合添加成员
- 删：remove 移除集合成员；clear 清空集合
- 改：无
- 查：has 查询成员是否在集合中（作为增删的先决条件）；size 查看集合中成员个数；values 返回包含集合所有成员的数组

代码实现：

```javascript
function Set() {
    var items = {};

    // 判断键是否存在
    this.has = function(key){
        return key in items;                  // 
        return items.hasOwnProperty(key);
    };

    // 添加成员
    this.add = function(value){
        if (!this.has(value)){              // 由于成员唯一，需要先判断是否已存在
            items[value] = value;           // value 同时作为键和值，方便查找
            return true;
        }   
        return false;                       // 返回是否添加成功
    };

    // 移除成员
    this.remove = function(value){
        if (this.has(value)){               // 存在才能移除，虽然可以移除不存在的属性，但是为了获取真正的执行结果，判断下
            delete items[value];
            return true; 
        }
        return false;
    };

    // 清除集合，指向到一个空对象最简单，好过遍历移除成员
    this.clear = function(){
        items = {};
    };

    // 获取成员数量
    this.size = function(){
        // 方法1：ES5 规范
        return Object.keys(items).length;

        // 方法2：兼容版本
        var count = 0;
        for(var prop in items) {
            if(items.hasOwnProperty(prop)) ++count; // 不能直接用 for in
        }
        return count;

        // 方法3：维护一个 length 内部变量
    }

    // 获取包含所有成员的数组
    this.values = function(){
        return Object.keys(items);  // 需要向下兼容的话就用 for in 遍历
    };
}
```

扩展：基于数组实现 Set 类

- 增加用 Array.prototype.push
- 删除用 Array.prototype.splice
- 查询用 Array.prototype.indexOf

## 5.3 集合操作

- 并集：包含俩个集合所有元素
```javascript
this.union = function(otherSet){
    var unionSet = new Set();               // 创建集合表示并集
    var values = this.values();             // 获取本集合的所有成员，遍历添加到并集
    for (var i=0; i<values.length; i++){
        unionSet.add(values[i]);
    }
    values = otherSet.values();             // 获取目标集合的所有成员，遍历添加到并集
    for (var i=0; i<values.length; i++){
        unionSet.add(values[i]);
    }
    return unionSet;                        // 返回并集
};
```
- 交集：包含两个元素公有元素
```javascript
this.intersection = function(otherSet){
    var intersectionSet = new Set();        // 创建集合表示交集
    var values = this.values();
    for (var i=0; i<values.length; i++){    // 遍历当前集合所有成员
        if (otherSet.has(values[i])){       // 如果该成员也存在于目标集合，则添加到交集
            intersectionSet.add(values[i]);
        } 
    }
    return intersectionSet;                 // 返回交集
}
```
- 补集/差集：属于集合一且不属于集合二的所有元素组成的集合
```javascript
this.difference = function(otherSet){
    var differenceSet = new Set();          // 创建集合表示差集
    var values = this.values();             
    for (var i=0; i<values.length; i++){    // 获取本集合所有成员遍历
        if (!otherSet.has(values[i])){      // 如果该成员不存在于目标集合，则添加到差集
            differenceSet.add(values[i]);   
        }
    }
    return differenceSet;                   // 返回差集
};
```
- 子集：验证是否为指定集合的子集
```javascript
this.subset = function(otherSet){
    if (this.size() > otherSet.size()){     // 优化处理，子集的成员数量一定不会大于父集，这种长度判断是常见的优化思路
        return false;
    } else {
        var values = this.values();
        for (var i=0; i<values.length; i++){
            if (!otherSet.has(values[i])){  // 遍历当前集合成员，如果成员不是目标集合的成员，则立即返回 false
                return false;
            } 
        }
        return true;                        // 能遍历完到这，说明是子集
    }
};
```

## 5.4 总结

用途、案例待添加。

相比其他语言，ES6原生实现也足以说明集合的重要性。

# 六、字典/映射 Dictionary/Map

上面集合的实现上，[值，值]的存储方式，虽然存储时数据即做键又做值的，实际上只有一个数据就是值本身（况且如果用数组实现，键都不需要了）。同样是用于存储不重复的值，字典和散列表则固定是用[键，值]对的形式来存储数据，我们放在一起对比着学习。两种数据结构实现上、用途上有什么区别？带着问题来继续学习。

### 6.1 基础概念

和集合一样，字典存储的也是不重复的元素，但和集合不同的是，字典使用[键，值]对的方式存储数据，使用键名来查询数据。乍听上去，这不就是 Javascript 中的 Object 对象吗？其实 Object 就是以字典的形式设计的。但是我们今天学习的字典不止是一个 Object。

和集合类似，ECMAScript2015 标准中也实现了一个 Map 类，接下来的学习是以 ES6 中 Map 类的实现为基础展开的。

### 6.2 实现字典

首先，我们需要一种数据结构来保存字典中的元素，既然想知道和 Javascript 中的 Object 有什么区别，我们就选择用对象来实现（当然数组也能实现字典，比如需要对键排序则用数组比较好）。

然后，考虑下所需的基本功能（方法），思考切入点增、删、改、查。

- 增：set 给字典添加元素
- 删：remove 移除字典元素；clear 清空字典
- 改：set 也可以更新元素
- 查：has 查询键是否在集合中；get 通过键查找值并返回； size 查看集合中成员个数；keys 返回包含字典所有键名的数组； values 返回包含字典所有成员的数组

代码实现：

```javascript
function Dictionary() {
    var items = {};

    this.has = function(key) {
        return key in items;
    }

    this.set = function(key, value) {
        items[key] = value;
    }

    this.remove = function(key) {
        if (this.has(key)) {
            delete items[key];
            return true;
        }
        return false;
    }

    this.get = function(key) {
        return this.has(key) ? items[key] : undefined;
    };
    
    this.clear = function(){
        items = {};
    };

    this.size = function(){
        return Object.keys(items).length;
    }

    this.kesy = function(){
        return Object.keys(items);
    };

    this.values = function() {
        var values = {};
        for (var k in items) {
            if (this.has(k)) {          // 需要先判断
                values.push(items[k]);
            }
        }
        return values;
    };
}

```

扩展：用数组实现字典

由于数组也是实现为对象的，所以数组也支持 arr[xxx] 的方式读写数据，只是这种情况下数组的 length 不会变化，而且 sort 方法也是一样不支持的，此时需要用 Object.keys 来转成数组在执行上述操作。但是这样的骚操作有啥特殊意义不？待补充

### 6.3 总结

Javascript 的 Object 类就是以字典的形式设计的。虽然看上去基于 Object 再去创建一个字典，没有太大意义，但是使用上会方便些，也可以内聚一些对整体操作的方法。至于实际的意义，还有待体会，实际用途有待发掘。

# 七、散列表/哈希表 HashTable

散列是一种常用的数据存储技术，散列后的数据可以快速地插入或取用。散列使用的数据结构叫做散列表。**在散列表上插入、删除和取用指定数据都非常快，但是对于指定条件的查找操作来说却效率低下**，比如查找一组数据中的最大值和最小值。这些操作得求助于其他数据结构，二叉查找树就是一个很好的选择。下面来看下如何实现散列表，并且了解什么时候应该用散列表存取数据。

## 7.1 基础概念

- 散列算法的作用：尽可能快地在数据结构中找到一个值（不需要遍历，直接获取值的具体位置）。
- 散列函数的作用：给定一个键值，然后返回值在表中的地址。
    - 理想情况下，散列函数会将每个键值映射为一个唯一的数组索引。
    - 实际情况下，键的数量是无限的，数组的长度是有限的，一个更现实的目标是让散列函数尽量将键均匀地映射到数组中。
    - 作用过程：键值对的键 -> 散列函数 -> 散列值（数字） -> 散列表（散列值+值）
- 散列表中的碰撞/冲突：即使使用一个高效的散列函数，仍然存在将两个键映射成同一个值的可能，这种现象称为碰撞，碰撞需要通过策略解决。

## 7.2 创建散列表

首先，下面的学习实现是基于数组，当然也可以用对象来实现。

- 散列表数组长度问题：
    - 其他语言中，数组是固定长度的，所以需要考虑预设数组长度，常见的限制是数组长度应该是一个质数，原因下面讨论；
    - 不过 Javascript 中的数组长度可以动态变化，这里可以暂时不考虑长度问题。

然后，考虑下所需的基本功能（方法），思考切入点增、删、改、查。

- 增：put 添加元素
- 删：remove 移除元素
- 改：无
- 查：get 查看元素

代码实现：以创建电话簿或者地址簿为例，key 是姓名

```javascript
function HashTable() {
    var table = [];                             // 如果需要指定长度，则 new Array(137) ，这个质数记住就行，很多例子用到

    // 私有的散列函数                             // 这个散列函数是很容易出现碰撞的
    var hashCode = function (key) {
        var hash = 0;                        
        for (var i = 0; i < key.length; i++) {  // 姓名的散列函数，最简单的用 ASCII 码相加后，除以一个质数
            hash += key.charCodeAt(i);
        }
        return hash % 37;                       // 如果预设了长度，也可以 hash % this.table.length
    };

    // 另一个散列函数
    var hashCode = function (key) {
        const H = 37;                        
        for (var i = 0; i < key.length; i++) {  // 和上面的区别是求和，每次都乘一个较小的质数，一般建议31，有碰撞就换大一些的37
            hash = H * hash + key.charCodeAt(i);
        }
        return hash % 137;
    };

    // 最被推荐的散列函数
    var hashCode = function (key) {
        var hash = 5381;
        for (var i = 0; i < key.length; i++) {  // 质数的选择变了，至于为什么这个选有兴趣可以去查看资料
            hash = hash * 33 + key.charCodeAt(i);
        }
        return hash % 1013;
    };

    this.put = function(key, value) {
        var position = hashCode(key);
        table[position] = value;
    };
    this.get = function (key) {
        return table[hashCode(key)];
    };
    this.remove = function(key) {
        table[hashCode(key)] = undefined;
    };
}

```

其实创建散列表的时候，主要需要考虑的是**用于散列化键值的散列函数**。选择合适的散列函数是个很难的问题。上面的例子只是个很简单的用于散列换字符串型键的散列函数，当然也可以用于数字型键。

## 7.3 处理碰撞

除了选择更优的散列函数来避免碰撞，在遇到碰撞时，还可以通过一定的策略来解决碰撞。常见的方法有：开链法/分离链接法、线性探测法、双散列法。这里我们只说前两种。

### 7.3.1 开链法/分离链接法

同一个元素不能存放多份数据，如果把元素设置成又一个数据结构，就可以存储多份数据了，比如数组（二维数组）、链表。此时，一个元素可以存储多份数据。这里我们先看用链表如何实现。

它是解决冲突的最简单的方法，但是它在 HashTable 实例之外还需要额外的存储空间。

在动手实现之前，先考虑下，前面的 put 方法是直接将 value 存到散列化后 key 对应的位置上了。如果此时我们用开链法来存储，同一个 key 下有多个数据，要想区分开他们，在存储的时候要把 key 和 value 一起存储下来。所以和链表的实现类似，我们先增加一个辅助类来用于数据的存储。

```javascript
var ValuePair = function(key, value){
    this.key = key;
    this.value = value;
    this.toString = function() {
        return '[' + this.key + ' - ' + this.value + ']';
    } 
};

this.put = function(key, value){
    var position = hashCode(key);
    if (table[position] == undefined) {                 // 第一次添加需要创建链表
        table[position] = new LinkedList();
    }
    table[position].append(new ValuePair(key, value));  // 存入带有 key 和 value 的实例
};

this.get = function(key) {
    var position = hashCode(key);
    if (table[position] !== undefined){                 // 存在数据则开始遍历链表
        var current = table[position].getHead();        // 获取头节点开始遍历
        while(current.next){
            if (current.element.key === key){           // 直到找到
                return current.element.value;
            }
            current = current.next;
        }
        if (current.element.key === key){               // 最后一个，没有 next 可以遍历，在主动查看
            return current.element.value;
        }
    }
    return undefined;                                   // 未找到
};

this.remove = function(key){
    var position = hashCode(key);
    if (table[position] !== undefined){                 // 同 get 先判断是否存在
        var current = table[position].getHead();
        while(current.next){
            if (current.element.key === key){           // 遍历
                table[position].remove(current.element);// 移除
                if (table[position].isEmpty()){
                    table[position] = undefined;        // 如果空了就置为 undefined
                }
                return true;                            // 删除成功
            }
            current = current.next;
        }
        if (current.element.key === key){               // 同样需要主动看最后一个
            table[position].remove(current.element);
            if (table[position].isEmpty()){
                table[position] = undefined;
            }
            return true;
        }
    }
    return false;                                       // 删除失败
};
```

补充：用数组实现的思路

- 存储的时候，用相邻的两个元素分别存储 key、value
- 读取的时候，自然需要在遍历时以 2 为步长

### 7.3.2 线性探测法

当想向表中某个位置加入一个新元素的时候，如果索引 为index的位置已经被占据了，就尝试index+1的位置。如果index+1 的位置也被占据了，就尝试 index+2的位置，以此类推，直达成功插入。

这种实现不需要额外的存储空间，但是在其他语言中需要注意数组是否被用完，Javascript 中不用考虑这个，因为数组会根据需要自动调整大小。

```javascript
this.put = function(key, value){
    var position = hashCode(key);
    if (table[position] == undefined) {                 // 位置空则直接插入
        table[position] = new ValuePair(key, value);
    } else {
        var index = ++position;                         // 否则向后逐个查找
        while (table[index] != undefined){
             index++;
        }
        table[index] = new ValuePair(key, value);       // 直到找到位置成功插入
    }
};
this.get = function(key) {
    var position = loseloseHashCode(key);
    if (table[position] !== undefined){                 // 查找都先判断当前key是否有值
        if (table[position].key === key) {
            return table[position].value;               // 当前是则直接返回
        } else {
            var index = ++position;                     // 不是则逐个向后查找
            while (table[index] === undefined || table[index].key !== key){ 
                index++;                                // 可能为空也可能key对不上，都不是需要的
            }
            if (table[index].key === key) {             // 循环结束了可能找到也可能没找到，还是要判断一下子
                return table[index].value;
            }
        } 
    }
    return undefined;                                   // 没找到
};

// remove 是找到的时候删掉，所以和 get 查找思路一样，只是要把 return 的地方换成 table[index] = undefined; （最后一个 return undefined 不用替换）
```

## 7.3 总结

开链法和线性探测法选择方法：
- 如果数组的大小是待存储数据个数的 1.5 倍，那么使用开链法;
- 如果数组的大小是待存储数据的两倍及两倍以上时，那么使用线性探 测法。

# 八、二叉树、二叉搜索树 BinarySearchTree BST

树是计算机科学中经常用到的一种数据结构。树是一种非线性的数据结构，以分层的方式存储数据。树相关的高级算法有很多，B+树、AVL树（自平衡二叉搜索树）红黑树（高效中序遍历），作为菜鸡的我还没接触到。我们先学一个特殊的、简单的、非常实用的**二叉树**。

先说下二叉树的优点，相比于数组易查找不易操作、链表易操作不易查找的情况，二叉树既易查找又易操作。

## 8.1 基本概念

- 边：连接节点的线
- 根节点：一棵树最上面的节点
- 父节点：下面连接多个节点的节点，除了根节点都有唯一父节点
- 子节点：父节点面的节点，一个节点可以有 0 个、1 个或多个子节点
- 叶子节点：没有任何子节点的节点
- 深度：节点的属性，取决于其祖先节点的数量
- 层次：根节点是第0层，根节点的子节点是第一层，子节点的子节点是第二层，以此类推
- 子树：由节点及其后代节点组成
- 二叉树：节点最多只能有两个子节点，一个是左侧子节点，另一个是右侧子节点
- 二叉搜索树：只允许在左侧节点存储(比父节点)小的值，在右侧节点存储(比父节点)大(或者等于)的值

## 8.2 创建二叉查找树

首先，由于需要保存节点的子节点信息，所以实现上类似与链表。也需要一个辅助类用于实例节点。

注意：不同于在之前将节点本身称作节点或项，我们将会称其为键。键是树相关的术语中对节点的称呼，下面使用 key 来表示数据也是契合语义的表现。

```javascript
var Node = function(key){
    this.key = key;
    this.left = null;
    this.right = null;
    this.show = function() {
        return this.key;
    }
};
```

然后，考虑下所需的基本功能（方法），思考切入点增、删、改、查。

- 增：insert 插入键
- 删：remove 移除键
- 改：无
- 查：search 查找指定键；min 查最小键；max 查最大键；inOrder 中序遍历；preOrder 先序遍历；postOrder 后序遍历

代码实现：

```javascript
function BinarySearchTree() {
    var root = null;            // 默认根节点为null
    
    this.insert = function(key){
        var newNode = new Node(key);
        if (root === null){
            root = newNode;
        } else {
            insertNode(root,newNode);
        } 
    };
    var insertNode = function(node, newNode){
        if (newNode.key < node.key){
            if (node.left === null){
                node.left = newNode;
            } else {
                insertNode(node.left, newNode);
            }
        } else {
            if (node.right === null){
                node.right = newNode;
            } else {
                insertNode(node.right, newNode);
            }
        } 
    };

    // 都是递归实现的
    // 对比下面三个遍历方法，会发现他们的区别就是：打印数据是在两个递归的中间、前面、后面
    // 用四层 BST 展示比较直观展示，下面的描述不是很好，找到图了再补上
    
    this.inOrder = function(callback){              // 根节点在结果的中间
        inOrderTraverseNode(root, callback);        // 从最小点到最大点
    };                                              // 看上去的路径像个 M
    var inOrderTraverseNode = function (node, callback) {
        if (node !== null) {
             inOrderTraverseNode(node.left, callback);
             console.log(node.show() + " ");
             callback(node.key);                       
             inOrderTraverseNode(node.right, callback);
        } 
    };


    this.preOrder = function(callback){             // 根节点在结果的开始
        preOrderTraverseNode(root, callback);       // 遍历每个子树都是先父节点再左再右节
    };                                              // // 从根节点开始向下
    var preOrderTraverseNode = function (node, callback) {
        if (node !== null) {
            console.log(node.show() + " ");
            callback(node.key);
            preOrderTraverseNode(node.left, callback);
            preOrderTraverseNode(node.right, callback);
        }
    };

    this.postOrder = function(callback){            // 根节点在结果的末尾
        postOrderTraverseNode(root, callback);      // 遍历每棵子树都是先左后右最后父节点
    };                                              // 一层一层向上直到根节点
    var postOrderTraverseNode = function (node, callback) {
        if (node !== null) {
            postOrderTraverseNode(node.left, callback);
            postOrderTraverseNode(node.right, callback);
            console.log(node.show() + " ");
            callback(node.key);                         
        } 
    };


    this.min = function () {                        // 最小的是最左边的节点
        return minNode(root);
    };
    var minNode = function (node) {                 // 后面删除也用得到
        if (node){
            while (node && node.left !== null) {
                node = node.left;
            }
            return node.key;
        }
        return null;
    };

    this.max = function () {                        // 最大的是最右边的节点
        return maxNode(root);
    };
    var maxNode = function (node) {
        if (node){
            while (node && node.right !== null) {
                node = node.right;
            }
            return node.key;
        }
        return null;
    };

    // 删除是个大问题，三种情况：无子节点、1个子节点、2个子节点
    this.remove = function(key){
        root = removeNode(root, key); 
    };

    var removeNode = function(node, key){
        if (node === null){                 // 结束遍历的标致
            return null;
        }
        if (key < node.key){                // 继续遍历左树
            node.left = removeNode(node.left, key);
            return node;
        } else if (key > node.key){         // 继续遍历右树
            node.right = removeNode(node.right, key);
            return node;
        } else {                            // 找到了
            if (node.left === null && node.right === null){
                node = null;                // 1、是个叶节点
                return node;
            }

            if (node.left === null){        // 2.1 有一个右子节点（不一定是叶节点）
                node = node.right;
                return node;

            } else if (node.right === null){// 2.2 有一个左子节点
                node = node.left;
                return node;
            }
            
            var aux = findMinNode(node.right); // 3、有两个子节点
            node.key = aux.key;              // 有两种思路，找到右子树的最小节点或左子树的最大节点，然后替换到被删除的节点，同时找到的那个节点在原位置删除
            node.right = removeNode(node.right, aux.key);

            return node;
        }       
    };
}
```

## 8.3 小结

这里只是学习了最简单的二叉搜索树，进一步需要掌握的是红黑树、AVL树，待补充

# 九、图、搜索（待补充）

广度优先搜索、深度优先搜索

# 十、排序算法

```javascript
// 测试用的方法
function ArrayList(){ 
    var array = [];
    this.insert = function(item){
        array.push(item);
    };
    this.toString= function(){
        return array.join();
    }; 
}
// 两个元素互换方法
var swap = function(index1, index2){
    var aux = array[index1];
    array[index1] = array[index2];
    array[index2] = aux;
};
```
下面的排序都是向着从小到大排。

## 10.1 冒泡排序 O(n²)

原理：相邻两个相比，根据结果调换二者的位置

从前向后遍历，每个元素都与其后面的元素相比较，外循环每一轮都选择一个最大的值冒泡到右侧

1. 第一次选出最大的调换到最后一位
2. 第二次选出第二大的调换到倒数第二位
3. 第三次选出第三大的调换到倒数第三位
...
n. 第n次比对1和2位
```javascript
this.bubbleSort = function(){
    var length = array.length;
    for (var i=0; i<length; i++){
        for (var j=0; j<length-1-i; j++ ){  // 优化点：比较过的不用再比较， length-1 => length-1-i
            if (array[j] > array[j+1]){
                swap(j, j+1);
            }
        }
    }
};
```

## 10.2 选择排序 O(n²)

原理：找到最小值，并放到第一位

1. 预设第一位最小，循环向后比较，出现比最小的还小的，则标记索引
2. 遍历完成后，比对预设的最小索引和比较出的最小索引是否相等，不等则调换
... 重复
```javascript
this.selectionSort = function(){
    var length = array.length,
        indexMin;
    for (var i=0; i<length-1; i++){
        indexMin = i;
        for (var j=i; j<length; j++){
            if(array[indexMin]>array[j]){
                indexMin = j;
            }
        }
        if (i !== indexMin){
            swap(i, indexMin);
        } 
    }
};
```

## 10.3 插入排序 O(n²)

原理：遍历数据结构，每一个已经遍历到的元素都会执行一次插入操作，先插入最后，然后向前遍历判断是否需要向前查找插入位置，直到查到0；已遍历完成的元素认为顺序已排。

```javascript
this.insertionSort = function(){
    var length = array.length,
        j, temp;
    for (var i=1; i<length; i++){
        j = i;
        temp = array[i];
        while (j>0 && array[j-1] > temp){
            array[j] = array[j-1];
            j--; 
        }
        array[j] = temp;
    }
};
```

### 进阶版插入排序：希尔排序

- 核心理念与插入排序 不同，它会首先比较距离较远的元素，而非相邻的元素

在开始做最后一次处理时，大部分元素都将在正确的位 置，算法就不必对很多元素进行交换。这就是希尔排序比插入排序更高效的地方

```javascript
// 预设好间隔
this.gaps = [5,3,1];
this.shellsort = function() {
    for (var g = 0; g < this.gaps.length; ++g) {
        for (var i = this.gaps[g]; i < array.length; ++i) {
            var temp = array[i];
            for (var j = i; j >= this.gaps[g] && array[j-this.gaps[g]] > temp; j -= this.gaps[g]) {
                array[j] = array[j - this.gaps[g]];
            }
            array[j] = temp;
        }
    } 
}
```
```javascript
// 动态计算间隔
function shellsort1() {
    var N = array.length;
    var h = 1;
    while (h < N/3) {
        h = 3 * h + 1;  // 1 4 13 40 
    }
    while (h >= 1) {
        for (var i = h; i < N; i++) {
            for (var j = i; j >= h && array[j] < array[j-h]; j -= h) {
                swap(j, j-h);
            }
        }
        h = (h-1)/3;        // 每次动态获选一个间隔
    }
}
```

## 10.4 归并排序 O(n㏒n) 

- 分治思路：将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组
- Firefox 中的 Array.prototype.sort 使用归并排序实现
- 小缺点：虽然非常容易实现，但是因为需要拆分成数组，所以空间复杂度大一些，不过目前来看空间不是主要约束条件，所以可以尝试

```javascript
this.mergeSort = function(){
    array = mergeSortRec(array);
};

var mergeSortRec = function(array){
    var length = array.length;
    if(length === 1) {
        return array;                   // 最终分割为只有1个元素的数组，就可以返回，开始递归向外的合并过程
    }
    var mid = Math.floor(length / 2),
        left = array.slice(0, mid),
        right = array.slice(mid, length);
    return merge(mergeSortRec(left), mergeSortRec(right));
};

var merge = function(left, right){      // 排序是在合并的过程中处理的
    var result = [],
        il = 0,
        ir = 0;
    while(il < left.length && ir < right.length) {
        if(left[il] < right[ir]) {      // 左边小，则把左边的元素添加到结果数组中，且左边的遍历索引++
            result.push(left[il++]);
        } else{                         // 右边小则操作右边
            result.push(right[ir++]);
        } 
    }
    while (il < left.length){           // 上面判断完以后，把剩下的左边的和右边的都添加到结果数组中
         result.push(left[il++]);       // 左和右最多只会生一个没添加完，由于剩下的也是已经排序的，所以可以直接添加到结果数组中
    }   
    while (ir < right.length){
        result.push(right[ir++]);
    }
    console.log(result);                // 可以用这个看一下递归的每层结果，比较直观
    return result;
};

eg: var arr = [10,12,1,3,7,6,2,8,4,5,9];
```

## 10.5 快速排序 O(n㏒n)

- 分治思路：将原始数组分 为较小的数组(但它没有像归并排序那样将它们分割开)
- Chrome 中的 Array.prototype.sort 使用快速排序的变体实现
- 通常快速排序比其他 O(n㏒n) 的算法要好，为什么？

```javascript
quickSort = function(array){
    quick(array, 0, array.length - 1);          // 重要概念：左指针指向第一位，右指针指向最后一位
};
var quick = function(array, left, right){
    var index;
    if (array.length > 1) {
        index = partition(array, left, right);  // 这个index划分操作返回的分割点 index 
    };
    console.log('left:',left, 'index:', index, "right:", right);
    if (left < index - 1) {                     // 如果左子数组存在较小元素，则递归执行
        quick(array, left, index - 1);
    }
    if (index < right) {                        // 右子数组同样判断是否需要递归
        quick(array, index, right);
    } 
}
var partition = function(array, left, right) {  // 划分操作
    var pivot = array[Math.floor((right + left) / 2)],  // 选择主元：这里选择中间位置的元素
        i = left,
        j = right;
    while (i <= j) {                            // 结束划分操作的条件，左右指针碰头/交错了
        while (array[i] < pivot) {              // 从left开始遍历，直到找到一个比主元大的元素或到主元，获取其索引待用
            i++;
            console.log('i:', i);
        }
        while (array[j] > pivot) {              // 从right开始遍历，找一个比主元小的元素或者主元，获取索引待用
            j--;
            console.log('j:', j);
        } 
        if (i <= j) {                           // 如果大于主元的元素索引比小于主元的元素索引小，说明二者需要调换
            console.log('i:', i, ' j:', j);
            swapQuickStort(array, i, j);        // 因为前面可能找到的是主元，所以主元也是会被移动的？
            console.log(array);
            i++;                                // 调换以后，继续找，直到两个索引碰头
            j--;
        }
    }
    console.log('一次划分完成，i:', i);
    return i;                                   // 返回最后二者碰头的位置
};
// 这里的 swap 操作要在递归中执行， array 不是固定的，所以单独写一个
var swapQuickStort = function(array, index1, index2){
    var aux = array[index1];
    array[index1] = array[index2];
    array[index2] = aux;
};

eg：var arr= [3,5,1,6,4,7,2];
```

```javascript
// 上面的看不懂，这个是二分排序
function quickSort(arr){
    // 如果数组<=1,则直接返回
    if(arr.length<=1){return arr;}
    
    var pivotIndex=Math.floor(arr.length/2);
    // 1. 找基准，并把基准从原数组删除
    var pivot=arr.splice(pivotIndex,1)[0];      // 也可以直接用第一个元素
    
    // 定义左右数组
    var left=[];
    var right=[];

    // 2. 比基准小的放在left，比基准大的放在right
    for(var i=0;i<arr.length;i++){
        if(arr[i]<=pivot){
            left.push(arr[i]);
        }
        else{
            right.push(arr[i]);
        }
    }
    // 3. 递归
    return quickSort(left).concat([pivot],quickSort(right));
}  
```

## 10.6 小结

# 十一、检索算法

下面只学习数据检索的一个方面：如何在列表中查找特定的值。有两种，顺序查找、二分查找。分别适用于不同情况。

## 11.1 顺序查找/线性查找

适用于：元素随机排列的列表

```javascript
this.sequentialSearch = function(item){
    for (var i=0; i<array.length; i++){
        if (item === array[i]) {
            return i;
        } 
    }
    return -1;
}:
```
```javascript
// 查最小值/最大值，思路类似与选择排序
function findMin(arr) {
    var min = arr[0];
    for (var i = 1; i < arr.length; ++i) {
        if (arr[i] < min) {
            min = arr[i];
        } 
    }
    return min; 
}
```

### 扩展：自组织数据（策略）

- 理论: 通过将频繁查找到的元素置于数据集的起始位置来最小化查找次数。
- 解释：对于未排序的数据集来说，当被查找的数据位于数据集的起始位置时，查找是最快、最成功的。通过将成功找到的元素置于数据集的起始位置，可以保证在以后的操作中该元素能被更快地查找到。数据的位置并非由程序员在程序执行之前就组织好，而是在程序运行过程中由程序自动组织的。
- 原则：80-20 原则
    - 是指对某一数据集执行的 80% 的查找操作都是对其中 20% 的数据元素进行查找。
    - 自组织的方式最终会把这 20% 的数据置于数据集的起始位置，这样便可以通过一个简单的顺序查找快速找到它们。
    - 概率分布被称为帕累托(Pareto)分布。

```javascript
// 实现1：查一次就往前移动一次，类似冒泡
function seqSearch(arr, data) {
    for (var i = 0; i < arr.length; ++i) {
        if (arr[i] == data) {
            if (i > 0) {
                swap(arr,i,i-1);
            }
            return true;
        }
    }
    return false;
}
// 实现2：只有当元素位于20%以外，才移动到首位
function seqSearch(arr, data) {
    for (var i = 0; i < arr.length; ++i) {
        if (arr[i] == data && i > (arr.length * 0.2)) {
            swap(arr,i,0);
            return true;
        } else if (arr[i] == data) {
            return true;
        }
    }   
    return false;
}
```

## 11.2 二分查找

适用于：元素顺序排列的列表，而且数据集越大效率越高，简单数据不太适合

```javascript
this.binarySearch = function(item){     // 实现上和 bst 的 search 一样，只是针对树结构
    this.quickSort();
    var low = 0,                 
        high = array.length - 1,
        mid, element;
    while (low <= high){
        mid = Math.floor((low + high) / 2);
        element = array[mid];
        if (element < item) {
            low = mid + 1;
        } else if (element > item) {
            high = mid - 1;
        } else {
            return mid;
        } 
    }
    return -1;
};
```

注意：如果有重复元素，二分查找返回的是连续重复元素中间的那个。

# 十二、动态规划

## 12.1 递归的问题

递归在代码层面看上去非常简洁，但是效率不高。包括 JavaScript 在内的众多语言，不能高效地将递归代码解释为机器代码，尽管写出来的程序简洁，但是执行效率低下。所以一个好的递归没有能实现成高级编程语言的特性，使之性能略低。而且一不留神搞错了停止条件还会无限递归，造成死循环，也就是所谓的栈溢出错误(stack overflow error)。

ES6 中的**尾调用优化**（tail call optimization）。如果函数内**最后一个操作是调用函数**，会通过“跳转指令”(jump) 而不是“子程序调用”(subroutine call)来控制。也就是说，在 ES6 中，这里的代码可以一直执行下去。所以，具有停止递归的边界条件非常重要。

## 12.2 斐波那契数列 对比递归和非递归的实现差别

1. 先看熟悉的递归实现方式。其性能差的原因是很多值在递归调用中被重复计算。
```javascript
function recurFib(n) {
    if (n < 2) {
        return 1; 
    } else {
        return recurFib(n-1) + recurFib(n-2);
    } 
    // return recurFib(n-1) + recurFib(n-2);  // 这样写会实现尾调用优化
}
```
2. 动态规划改写，存储中间的计算结果
```javascript
function dynFib(n) {
    var val = [];                       // 创建缓存数组
    for (var i = 0; i <= n; ++i) {
        val[i] = 0; 
    }
    
    if (n == 1 || n == 2) {             // 特殊情况处理
        return 1;
    } else {
        val[1] = 1;
        val[2] = 2;
        for (var i = 3; i <= n; ++i) {  // 
            val[i] = val[i-1] + val[i-2];
        }
        return val[n-1];
    }
}
```
3. 动态规划，但是不存储中间结果，而是迭代
```javascript
function iterFib(num) {
    var n1 = 1,
        n2 = 1,
        n = 1;
    for (var i = 3; i<=num; i++){
        n = n1 + n2;
        n1 = n2;
        n2 = n;
    }
    return n;
}
```

当计算的目标值越大的时候，动态规划性能提升越明显。简单的情况下（嵌套不深）递归效率还是可以的。而且用递归也是因为它更容易解决问题。

## 12.3 动态规划

> - 从最小的问题入手解决，直到合并成整体解决方案。
> - 要注意动态规划和分而治之(归并排序和快速排序算法中用到的那种)是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。

动态规划有时被认为是一种与递归相反的技术。递归是从顶部开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整个问题。动态规划解决方案从底部开始解决问题，将所有小问题解决掉，然后合并成一个整体解决方案，从而解决掉整个大问题。

许多使用递归去解决的编程问题，可以重写为使用动态规划的技巧去解决。**动态规划方案通常会使用一个数组来建立一张表，用于存放被分解成众多子问题的解**。

用动态规划解决问题时，要遵循三个重要步骤:

1. 定义子问题;
2. 实现要反复执行而解决子问题的部分(这一步要参考前一节讨论的递归的步骤);
3. 识别并求解出边界条件。

## 12.3 常见案例

### 12.3.1 背包问题

简单算法：计算每种组合，费时。后面要学的贪心算法可以求得近似最优解，但还不是最优解。下面我们看下怎么用动态规划求取最优解。

> 在搞懂概念之前，我们可以用表格的方法来进行理解。

可选选项\约束条件（背包容量kg） | 1 | 2 | 3 | 4
---|---|---|---|---
吉他 $1500 1kg| 1500 | 1500 | 1500 | 1500
音响 $3000 4kg| ~~0~~vs1500 | ~~0~~vs1500 | ~~0~~vs1500 | ~~1500~~vs3000
电脑 $2000 3kg| ~~0~~vs1500 | ~~0~~vs1500 | 2000vs~~1500~~ | 2000+1500vs~~3000~~
手机 $2000 1kg| 2000vs~~1500~~ | 2000+1500vs~~1500~~ | 2000+1500vs~~2000~~ | 2000+2000vs~~3500~~

**过程**：
1. 每行表示选择该产品时，不同背包容量下的最大金额（最后一个最大）；每列表示该背包容量下，不同产品选择的最大金额（最后一个最大）
2. 逐行填写，填写的时候遵循以下判断：
    1. 背包容量1时，是否可以选择当前产品，不能选择时，沿用上一行的结果
    2. 可以选择当前产品时，计算当前产品总额+剩余容量对应上一行的结果，然后和当前列的上一个值比较，选择较大值填入

**公式**：
- cell[i][j] = cell[i-1][j] vs（当前产品金额 + cell[i-1][剩余背包容量 = j - 当前商品重量]）

**总结**：
1. 沿着一列往下走时，最大价值不可能降低，因为每次都存的最大值
2. 行的顺序无关，但是先填行还是先填列可能有影响
3. 增加一个产品时，一般不需要修改当前表格，继续添加行就行；但是如果产品的重量不是整数，需要粒度更细的话，就要重填表格
4. 这个产品不能只取一部分
5. 两个产品不能有相互依赖，不然没办法建模，**仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用**
6. 不会涉及两个以上的子背包，但是子背包可以又包含子背包
7. 最优解可能填不满背包

## 12.4 解题步骤

### 1. 绘制网格

1. 单元格中的值：通常就是要优化的值，也就是目标值
2. 网格的坐标轴：
3. 子问题的划分

### 2. 填充网格



# 十三、贪心算法

> - **每步都选择局部最优解**，直到合并成全局近似最优解。（大部分最优，小部分不是最优）
> - 处理不可能完成的任务，没有快速算法的问题(NP完全问题)。

贪心算法是一种以寻找“优质解”为手段从而达成整体解决方案的算法。这些优质的解决方案称为局部最优解，将有希望得到正确的最终解决方案，也称为全局最优解。“贪心” 这个术语来自于这些算法无论如何总是选择当前的最优解这个事实。通常，贪心算法会用于那些看起来近乎无法找到完整解决方案的问题，然而，出于时间和空间的考虑，次优解也是可以接受的。

在有些情况下，完美是优秀的敌人。有时候，你只需找到一 个能够大致解决问题的算法，此时贪婪算法正好可派上用场，因为它们实现起来很容易，得到的 结果又与正确结果相当接近。

## 13.1 集合覆盖问题

假设你办了个广播节目，要让全美50个州的听众都收听得到。为此，你需要决定在哪些广播台播出。在每个广播台播出都需要支付费用，因此你力图在尽可能少的广播台播出，每个广播台都覆盖特定的区域，不同广播台的覆盖区域可能重叠。

上面问题最优解的求解步骤：列出所有可能（有可能 2^n 个），然后从中选择。你会发现 n 较小的时候还能执行，但是随着 n 增大，计算量陡增。这是不能被接受的。所以我们尝试用下面的步骤求近似最优解：

1. 选出一个覆盖最多未覆盖区域的选项，不考虑重复
2. 继续重复上面的选择，直到所有区域被覆盖

判断近似算法优劣的标准如下: 
- 速度有多快
- 得到的近似解与最优解的接近程度

代码实现步骤：
1. 创建一个集合，用来存储所有区域，表示为未覆盖区域；可选择项存到一个散列表中；另一个集合表示选择
2. 遍历选项，找一个和未覆盖区域集合**交集**最大的选项
3. 将该选项存入结果，同时更新未覆盖区域的集合
4. 重复2、3，直到未覆盖区域集合为空

## 13.2 旅行商问题

旅行商需要前往5个不同的城市，他需要找出前往这5个城市的最短路径，为此，必须计算每条可能的路径。

前往 n 个城市的可能路径总数是 n！，阶乘函数(factorial function)。5! = 120 10! = 3 628 800，可以看到可能线路数增加非常快。

**近似求解**：随便选择出发城市，然后每次选择要去的下一个城市时，都选择还没去的最近的城市。

## 13.3 NP 完全问题

旅行商问题和集合覆盖问题有一些共同之处:你需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。

NP完全问题的简单定义是，以难解著称的问题，如旅行商问题和集合覆盖问题，暂时找不到可快速解决这些问题的算法。

### 如何识别 NP 完全问题

eg：从A到B的最短路径是可以求出来的，如果最短路径要指定几个点就是旅行商问题-NP完全问题。

判断方法：
- 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢（**阶乘函数**）。
- 涉及“**所有组合**”的问题通常是NP完全问题。
- **不能将问题分成小问题，必须考虑各种可能**的情况。这可能是NP完全问题。
- 如果问题涉及序列(如旅行商问题中的城市序列)且难以解决，它可能就是NP完全问题。 
- 如果问题涉及集合(如广播台集合)且难以解决，它可能就是NP完全问题。
- 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。

## 13.4 其他案例

1. 最少硬币找零

- 思路：从最大面额的硬币开始，拿尽可能多的这种硬币找零。当无法再拿更多这种价值的硬币时，开始拿第二大价值的硬币，依次继续。
- 实现：从大到小遍历面值，每次都拿当前面值累加计算，直到计算结果超过总值，继续用同样方法计算下一个面值

# 补充

# 傅里叶变换
