# 一、编译原理

## 1、三个步骤

- 分词/词法分析(Tokenizing/Lexing) 
    - 将字符串分解成有意义的代码块，即`词法单元(token)`
    - eg：var a = 2; 分解成 var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义
- 解析/语法分析(Parsing) 
    - 将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的`“抽象语法树”(Abstract Syntax Tree，AST)`
- 代码生成
    - 将 AST 转换为`可执行代码(机器指令)`
    - eg: 将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中

## 2、js中的编译

- 作为动态语言，JS 的编译过程发生着在执行前，而非构建前（所以优化时间不长）
- JS 在执行前的编译，是做好执行的准备，通常会马上执行（但编译和执行依然是分开的）
- 超短的编译时间内，JS 引擎做了很多优化来保证性能（JIT，延迟编译甚至重编译）

# 二、作用域基本说明

## 1、三个角色

- 引擎
    - 负责整个程序的编译及执行过程
- 编译器
    - 负责语法分析及代码生成
- 作用域
    - 负责收集并维护声明变量的查询，实施`查询规则`，确定当前执行代码对变量的`访问权限`
    - 简单说，`根据名称查找变量的一套规则`

## 2、查询说明

- LHS 左查询
    - 变量在赋值操作的左侧
        - 不一定是=赋值操作符的左侧
        - eg：调用 func(2) 给 func(a){} 传参时，有隐式赋值操作 a = 2，也是 LHS
    - 目的是对变量进行复制
- RHS 右查询
    - 变量在赋值的右侧
        - 不一定是=赋值操作符的右侧
        - eg：func(2) 调用方法也是 RHS
    - 目的是获取变量的值

### 一个例子

```js
function foo(a) { 
    console.log( a ); // 2
}
foo( 2 );
```
1. foo() 调用函数，对 foo 进行 RHS 引用
2. 隐式赋值 a=2，对 a 进行 LHS 查询
3. 对 console 对象进行 RHS 查询 log 方法
4. 给 log 方法传参，通过变量 a 的 RHS 查询

## 3、作用域嵌套/作用域链

- 出现
    - 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套
- 规则
    - 在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找
    - 直到找到该变量，或抵达最外层的作用域(也就是全局作用域)为止

## 4、两种异常

- ReferenceError 未定义
    - RHS 查询在所有嵌套的作用域中遍寻不到所需的变量
    - eg：当 a 未定义时使用 a 进行 RHS 变量值查询
        - 注意和后面的变量提升时使用 a 获取 undefined 区别，一个是报错，一个是空值
- TypeError 类型错误
    - 尝试对这个变量的值进行不合理的操作
    - eg：当 a 不是函数时执行 a() 

# 三、词法作用域

> 简单说，词法作用域定义在`词法阶段`的作用域，可以认为在编码时就决定(大部分情况下)，帮助运行时快速查找。属于执行上下文的一部分

## 1、查找规则

### 1.1 变量
 
引擎通过作用域提供的位置信息来查找标识符(变量)。

- 作用域查找会在找到第一个匹配的标识符时停止
    - 多层嵌套作用域中的同名标识符存在`遮蔽效应`，window.xx 可以绕开
- 当前作用域中找不到，引擎会在外层嵌套作用域中查找，直到找到该变量，或抵达最外层的全局作用域为止
- 词法作用域查找只会查找一级标识符
    - 如 a.b 只会视图查找 a ，找到后在访问 a 的属性 b

### 1.2 函数

无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处 的位置决定

## 2、特例(词法欺骗)

运行时进行欺骗，evel 是运行时修改已存在的词法作用域， with 是运行时创建新的词法作用域。

### 2.1 eval

无论何种情况，eval(..) 都可以在运行期修改书写期的词法作用域。

```js
function foo(str, a) { 
    eval( str ); // 欺骗! 
    console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```

eval 的参数常使用动态生成的代码，这种操作并不提倡，而且好处有限，性能损耗更大，得不偿失。

### 2.2 with

with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。

```js
function foo(obj) {
    with (obj) {
        a = 2;  // 看起来只是对变量 a 进行简单的词法引用，实际上就是一个 LHS 引用，并将 2 赋值给它
    }
}
var o1 = { 
    a: 3
};
var o2 = { 
    b: 3
};
foo( o1 ); // 传入 o1 时，有 o1.a 就对其赋值了，所以下面是2
console.log( o1.a ); // 2
foo( o2 ); // 传入 o2 时，o2 没有 a 属性，不进行赋值，所以下面是 undefined
console.log( o2.a ); // undefined
console.log( a ); // 2 ，a 被泄漏到全局作用域上了! o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a=2 执行时，自动创建了一个全局变量(此时为非严格模式)
```

with 这种将对象及其属性放进一个作用域并同时分配标识符的行为很让人费解。并且在严格模式下，with 被完全禁止，所以基本上没见过 with 使用。

### 2.3 性能

eval(..) 和 with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。但这种骚操作并没有给我们带来更多的好处，实现的功能有限，代码难阅读、不可控、没有扩展性，像是个很操蛋的东西。

而且 JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。上面这两个语法，引擎无法判断该如何优化，所以最简单的做法就是`完全不做任何优化`，所以这两个东西的用途真的一坨~，不要用！

# 四、函数作用域

函数作用域是最常见的作用域单元。

## 1、含义

声明在函数内的变量，可以在整个函数范围内(嵌套的作用域中也可以)使用及复用，默认情况下外部作用域访问不到。或者可以说函数内的任何声明(变量或函数)都绑定在该函数作用域中。

## 2、用途

- 隐藏内部实现
    - 外部作用域无法访问包装函数内部的任何内容
- 规避命名冲突

## 3、函数声明和函数表达式

- 函数声明
    - function 关键字在整个声明中的第一位置
    - function foo(){}
    - foo 绑定在所在作用域中，可以直接通过 foo 调用
        - 可能会被认为 foo '污染'了所在作用域
- 函数表达式
    - function 关键字不在第一位置
    - (function foo(){})
    - foo 绑定在函数表达式自身的函数中，而非所在作用域中
        - 此时不会污染外部作用域
        - 可以试下，在外面访问 foo 会报错 ReferenceError

## 4、匿名函数的缺点

1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用
    - 递归
    - 事件触发后事件监听器需要解绑自身
3. 匿名函数省略了对于代码可读性/可理解性很重要的函数名

## 5、IIFE(立即执行函数表达式)

说明：
- (function foo(){ .. })() 中第一个 () 将函数变成表达式，第二个 () 执行了这个函数
- 函数名非必须，常用匿名函数
- 另一种写法 (function foo(){ .. }()) 功能无区别

# 五、块作用域

## 1、用途

- 保证变量不会被混乱地复用及提升代码的可维护性
- 变量的声明应该距离使用的地方越近越好，并最大限度地本地化
- 将代码从在函数中隐藏信息扩展为在块中隐藏信息(进一步缩小范围)，可以理解为最小授权原则进行扩展的工具

## 2、es3中的块作用域

- with
    - 用 with 从对象中创建出的作用域仅在 with 声明中而非外 部作用域中有效
    - 不推荐用，知道有这么回事就行
- try/catch
    - catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效
    - 常用的 err 作为 catch 的参数，此时 err 只能在 catch 分句内访问

## 3、es6中的块作用域

- let
    - 隐式绑定所在块作用域，通常是 {} 内部
        - 既然是隐式的，那么在开发和修改过程中就得注意下绑定关系，否则容易出问题
    - 可以显式的创建块，使得绑定关系变得清晰
        - 在声明中的任意位置都可以使用 { .. } 括号来为 let 创建一个用于绑定的块
    - 常用场景：`let 循环`
        - for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中
        - 事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值`重新进行赋值`
- const
    - 常量，其他同 let

# 六、提升

任何声明在某个作用域内的变量，都将附属于这个作用域。但是不同声明的位置可能带来不同的执行结果，这就是`提升`造成的影响。

## 1、表现

执行顺序和书写顺序并非完全一致。经典面试题：

```js
var a = 1;
function test() {
    console.log(a); // undefined
    var a = 2;
    console.log(a); // 2
}
test();
```

## 2、原因

- 编译
    - 在编译阶段找到所有声明，并用合适作用域关联，即词法作用域
    - test 函数中 var a = 2; 会被拆分处理，第一部分`定义声明 var a`在编译阶段进行
    - 变量和函数声明会在编译阶段进行提升
- 运行时
    - 第二部分`赋值声明 a = 2`在执行阶段进行
    - 赋值或其他运行逻辑会被留在原地等待执行
        - 因为如果这一部分也提升，那么代码执行顺序会改变，程序将不再可控

## 3、表现

- 变量提升
    - 只提升变量声明，不提升变量赋值
    - let 和 const 提升，但因为暂时性死区，导致无法提前访问
- 函数提升
    - 只有函数声明会被提升，函数表达式不会被提升
        - 提升 function xx(){}
        - 不提升 (function xx(){})、var xx = function(){}
    - 函数提升先于变量提升

# 七、闭包

> 当函数可以`记住并访问所在的词法作用域`，即使函数是在当前词法作用域之外执行，这时就产生了闭包。

## 1、描述

```js
function foo() { 
    var a = 2;
    function bar() { 
        console.log( a );
    }
    return bar; 
}
var baz = foo();
baz(); // 2 闭包
```

1. 函数 foo 执行返回函数 bar (函数作为值类型进行传递)
2. bar 在其词法作用域外执行时，保持了对 foo 内部作用域的访问(可以打印出 a)
3. 通常 foo 执行后，其内部作用域会被销毁，此时 baz(即 bar) 保持了对该内部作用域的引用，阻止了销毁，这个引用就叫闭包

## 2、特征

- 为创建内部作用域而调用了一个包装函数
- 包装函数的返回值必须至少包括一个对内部函数的引用
    - 函数作为值类型进行传递

补充：IIFE 本身并不是闭包，它依然是在本身的词法作用域内再执行的。但是常用它来创建闭包。

## 3、常用场景：for 循环

经典面试题：从1输出到5

- 错误写法：
    ```js
    for (var i = 1; i <= 5; i++) { 
        setTimeout( function timer() {
            console.log( i ); // 输出5次 6
        }, i * 1000 );
    }
    ```
    - 尽管循环中五个函数是在各个迭代中分别定义，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i
    - 在函数真正执行的时候，访问到的 i 均是全局作用域中的 i，在循环结束后 i = 6
- 正确写法：
    ```js
    for (var i = 1; i <= 5; i++) { 
        (function(j) {
            setTimeout( function timer() { 
                console.log( j );
            }, j * 1000 );
        })( i );
    }
    ```
    - 在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域
    - 此时，延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中变量值就是正确的了
- 其他写法：
    - 可以在 for 循环头部用 let 进行声明，具体原因见 五、3

## 4、内存泄漏

一直有一个误导说法，闭包可能导致内存泄漏。但其实仔细想一下，`变量放在闭包中和放在全局作用域，对内存方面的影响是一致的`。所以闭包并不是导致内存泄漏的罪魁祸首。

真正导致内存泄漏的原因是，`循环引用`，而闭包非常容易形成循环引用，进而引起内存泄漏，然后背锅到现在。

把循环引用中的变量赋值为 null，来切断变量和它此前引用之间的连接，可以解决内存泄漏问题。(也有个说法：设置为 null 为了让其被垃圾回收，这个也并非该操作的本意)