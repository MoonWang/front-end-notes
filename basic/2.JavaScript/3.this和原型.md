早期学习的过程中，一直被灌输一种思想，在 JS 中实现面向对象编程是一件非常有逼格、非常提现编程能力、非常高效... 的骚操作，但事实真的是这样吗？JS 真的需要面向对象编程和类吗？

> OOP 降低复杂度是靠良好的封装、继承、多态以及接口定义。

207 294 307

# 一、this

this 是个关键字，是 JS 中最复杂的机制之一，被自动定义在所有函数的作用域中。而且经常会被开发人员搞混。

## 1、为什么要用 this

在实际开发中我们经常需要在不同的`上下文对象`中`重复`使用某一个函数，为了不用特殊处理，我们经常会是用 this 来做一些事情，比如调用 this 的某些属性、方法。

如果我们不使用 this ，就得显式的传入一个上下文对象，这样的话在项目体积增大的时候，随着使用模式越来越复杂，显式传递上下文对象会让代码变得越来越`混乱`。

而 this 提供了一种更优雅的方式来隐式“传递”一个对象引用，自动引用合适的上下文对象，可以使得代码更`简洁并易于复用`。

## 2、常见误解

- this 指向函数本身
    - 无法是用 this 实现调用函数这个对象，即 this.xx != func.xx
    - 通常调用函数自身，可以使用具名函数、arguments.callee(已弃用)
- this 指向函数作用域
    - `任何情况下都不指向函数的词法作用域`，即使看上去像是这么回事
    - 注意：词法作用域和对象类似，但只存在于引擎内部，无法访问，不能和 this 混用

## 3、相关机制

- `运行时绑定`，非编写时绑定(不包括箭头函数)
- 绑定结果和函数声明位置无关，`只取决于函数调用方式`
- this 是执行上下文的一个属性
    - 函数调用时，会创建执行上下文，包括函数调用栈、函数调用方法、传入参数等信息

## 4、运行时的绑定规则

函数执行过程中调用位置决定 this 绑定规则，一共有四条：默认绑定、隐式绑定、显式绑定、new 绑定，分别认识一下，并判断其优先级。此外还有绑定例外的情况和自定义软绑定的实现方式。

### 4.1 默认绑定

- `无任何修饰的独立函数调用`，此时 this 指向全局对象
- 但是严格模式下是无法绑定到全局对象，而是绑定到 undefined 
- 可以认为是兜底的默认规则，其他规则不适用时，这条规则就顶上。

### 4.2 隐式绑定

- `调用位置有上下文对象`，如 obj.func() 此时 this 指向该上下文对象
- 意外情况
    - 隐式绑定丢失
        - 如，函数作为参数传递时，像回调函数、定时器函数
    - this 绑定被修改

### 4.3 显式绑定

- call/apply
    - 参数1为 this 绑定对象，参数2位函数的参数，call 是分开传递，apply 是用数组传递
    - 无法解决绑定丢失的问题，因为 call 和 apply 调用即执行，而上面的丢失情况是延迟执行的
- bind
    - ES5 中出现，也叫硬绑定

### 4.4 new 绑定

### 4.5 优先级

### 4.6 绑定例外

### 4.7 自定义软绑定

## 5、ES6 词法

# 二、对象

## 1、语法

## 2、内置对象

## 3、内容/属性

### 3.1 

## 4、遍历操作

# 三、类

# 四、原型

# 五、行为委托

# 六、ES6 class
